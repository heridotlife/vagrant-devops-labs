# -*- mode: ruby -*-
# vi: set ft=ruby :

#############################################################################
# Kubernetes Lab - Vagrantfile (MVP)
#############################################################################
# This Vagrantfile defines the virtual machines for the Kubernetes cluster.
# Configuration is loaded from .env file.
#
# Topology (MVP):
#   - 1 master node (control plane)
#   - 2 worker nodes
#
# Requirements:
#   - VirtualBox 7.0+
#   - Vagrant 2.3+
#   - vagrant-hostmanager plugin
#   - vagrant-vbguest plugin
#############################################################################

require 'fileutils'

# Load environment variables from .env file
def load_env_file
  env_file = File.join(File.dirname(__FILE__), '.env')

  unless File.exist?(env_file)
    puts "ERROR: .env file not found!"
    puts "Please run: make init (or cp .env.example .env)"
    exit 1
  end

  # Parse .env file
  File.readlines(env_file).each do |line|
    line.strip!
    next if line.empty? || line.start_with?('#')

    if line =~ /^([A-Z_][A-Z0-9_]*)=(.*)$/
      key = $1
      value = $2
      # Remove quotes if present
      value = value.gsub(/^["']|["']$/, '')
      ENV[key] = value
    end
  end
end

# Load .env
load_env_file

#############################################################################
# Configuration from environment variables
#############################################################################

CLUSTER_NAME = ENV['CLUSTER_NAME'] || 'k8s-lab'
K8S_VERSION = ENV['K8S_VERSION'] || '1.31.0'

# VM Configuration
VM_OS = ENV['VM_OS'] || 'centos-stream-9'
VM_BOX = ENV['VM_BOX'] || 'generic/centos9s'
VM_BOX_VERSION = ENV['VM_BOX_VERSION'] || '4.3.12'

# Node counts
VM_COUNT_MASTERS = (ENV['VM_COUNT_MASTERS'] || 1).to_i
VM_COUNT_WORKERS = (ENV['VM_COUNT_WORKERS'] || 2).to_i

# Master resources
VM_MASTER_CPUS = (ENV['VM_MASTER_CPUS'] || 2).to_i
VM_MASTER_MEMORY = (ENV['VM_MASTER_MEMORY'] || 2048).to_i

# Worker resources
VM_WORKER_CPUS = (ENV['VM_WORKER_CPUS'] || 2).to_i
VM_WORKER_MEMORY = (ENV['VM_WORKER_MEMORY'] || 2048).to_i

# Network configuration
NETWORK_CIDR = ENV['NETWORK_CIDR'] || '10.240.0.0/24'
MASTER_IP_START = ENV['MASTER_IP_START'] || '10.240.0.11'
WORKER_IP_START = ENV['WORKER_IP_START'] || '10.240.0.21'

# API Server port forwarding
API_SERVER_HOST_PORT = (ENV['API_SERVER_HOST_PORT'] || 6443).to_i

# Hostmanager
VAGRANT_HOSTMANAGER = ENV['VAGRANT_HOSTMANAGER'] != 'false'
UPDATE_HOST_HOSTS = ENV['UPDATE_HOST_HOSTS'] != 'false'

#############################################################################
# Helper Functions
#############################################################################

def master_ip(index)
  base = MASTER_IP_START.split('.').map(&:to_i)
  base[3] += index - 1
  base.join('.')
end

def worker_ip(index)
  base = WORKER_IP_START.split('.').map(&:to_i)
  base[3] += index - 1
  base.join('.')
end

def generate_inventory(masters, workers)
  inventory_dir = File.join(File.dirname(__FILE__), 'ansible', 'inventory')
  FileUtils.mkdir_p(inventory_dir)

  inventory_file = File.join(inventory_dir, 'hosts.ini')

  File.open(inventory_file, 'w') do |f|
    f.puts "# Ansible Inventory - Auto-generated by Vagrant"
    f.puts "# Do not edit manually - will be overwritten"
    f.puts ""

    # Masters
    f.puts "[masters]"
    masters.each do |node|
      f.puts "#{node[:name]} ansible_host=#{node[:ip]} ansible_user=vagrant ansible_ssh_private_key_file=.vagrant/machines/#{node[:name]}/virtualbox/private_key"
    end
    f.puts ""

    # Workers
    f.puts "[workers]"
    workers.each do |node|
      f.puts "#{node[:name]} ansible_host=#{node[:ip]} ansible_user=vagrant ansible_ssh_private_key_file=.vagrant/machines/#{node[:name]}/virtualbox/private_key"
    end
    f.puts ""

    # All nodes
    f.puts "[k8s_cluster:children]"
    f.puts "masters"
    f.puts "workers"
    f.puts ""

    # etcd nodes (on master for MVP)
    f.puts "[etcd]"
    masters.each do |node|
      f.puts "#{node[:name]} ansible_host=#{node[:ip]}"
    end
    f.puts ""

    # Group vars
    f.puts "[k8s_cluster:vars]"
    f.puts "ansible_python_interpreter=/usr/bin/python3"
    f.puts "k8s_version=#{K8S_VERSION}"
    f.puts "cluster_name=#{CLUSTER_NAME}"
  end

  puts "✓ Generated Ansible inventory: #{inventory_file}"
end

#############################################################################
# Vagrant Configuration
#############################################################################

Vagrant.configure("2") do |config|
  # Global VM settings
  config.vm.box = VM_BOX
  config.vm.box_version = VM_BOX_VERSION
  config.vm.box_check_update = false

  # SSH configuration
  config.ssh.insert_key = false
  config.ssh.forward_agent = true

  # Disable default shared folder
  config.vm.synced_folder ".", "/vagrant", disabled: true

  # Share configs directory (for certificates, manifests)
  config.vm.synced_folder "./configs", "/vagrant/configs",
    type: "rsync",
    rsync__exclude: [".git/", "*.pem", "*.key"]

  # Hostmanager plugin configuration
  if Vagrant.has_plugin?("vagrant-hostmanager")
    config.hostmanager.enabled = VAGRANT_HOSTMANAGER
    config.hostmanager.manage_host = UPDATE_HOST_HOSTS
    config.hostmanager.manage_guest = true
    config.hostmanager.ignore_private_ip = false
    config.hostmanager.include_offline = true
  end

  # VBGuest plugin configuration
  if Vagrant.has_plugin?("vagrant-vbguest")
    config.vbguest.auto_update = false
  end

  # Node definitions
  nodes = []

  #############################################################################
  # Master Nodes
  #############################################################################

  (1..VM_COUNT_MASTERS).each do |i|
    node_name = "master-%02d" % i
    node_ip = master_ip(i)
    nodes << { name: node_name, ip: node_ip, type: 'master' }

    config.vm.define node_name, primary: (i == 1) do |master|
      master.vm.hostname = node_name

      # Network configuration
      master.vm.network "private_network", ip: node_ip

      # Port forwarding for API server (first master only)
      if i == 1 && API_SERVER_HOST_PORT > 0
        master.vm.network "forwarded_port",
          guest: 6443,
          host: API_SERVER_HOST_PORT,
          auto_correct: false
      end

      # VirtualBox provider
      master.vm.provider "virtualbox" do |vb|
        vb.name = "#{CLUSTER_NAME}-#{node_name}"
        vb.cpus = VM_MASTER_CPUS
        vb.memory = VM_MASTER_MEMORY
        vb.linked_clone = true

        # VirtualBox optimizations
        vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]
        vb.customize ["modifyvm", :id, "--ioapic", "on"]
        vb.customize ["modifyvm", :id, "--paravirtprovider", "kvm"]

        # GUI settings (disabled)
        vb.gui = false
      end

      # Provisioning
      master.vm.provision "shell", inline: <<-SHELL
        echo "Provisioning master node: #{node_name}"
        echo "IP: #{node_ip}"
        echo "Kubernetes version: #{K8S_VERSION}"

        # Set hostname
        hostnamectl set-hostname #{node_name}

        # Add all cluster nodes to /etc/hosts
        cat >> /etc/hosts <<EOF
# Kubernetes cluster nodes
#{nodes.map { |n| "#{n[:ip]} #{n[:name]}" }.join("\n")}
EOF

        # Disable SELinux (required for Kubernetes)
        setenforce 0 || true
        sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

        # Disable swap
        swapoff -a
        sed -i '/ swap / s/^/#/' /etc/fstab

        # Load kernel modules
        modprobe overlay
        modprobe br_netfilter

        # Persist kernel modules
        cat > /etc/modules-load.d/k8s.conf <<EOF
overlay
br_netfilter
EOF

        # Sysctl params for Kubernetes
        cat > /etc/sysctl.d/k8s.conf <<EOF
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
        sysctl --system

        echo "✓ Master node #{node_name} pre-provisioned"
      SHELL
    end
  end

  #############################################################################
  # Worker Nodes
  #############################################################################

  (1..VM_COUNT_WORKERS).each do |i|
    node_name = "worker-%02d" % i
    node_ip = worker_ip(i)
    nodes << { name: node_name, ip: node_ip, type: 'worker' }

    config.vm.define node_name do |worker|
      worker.vm.hostname = node_name

      # Network configuration
      worker.vm.network "private_network", ip: node_ip

      # VirtualBox provider
      worker.vm.provider "virtualbox" do |vb|
        vb.name = "#{CLUSTER_NAME}-#{node_name}"
        vb.cpus = VM_WORKER_CPUS
        vb.memory = VM_WORKER_MEMORY
        vb.linked_clone = true

        # VirtualBox optimizations
        vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]
        vb.customize ["modifyvm", :id, "--ioapic", "on"]
        vb.customize ["modifyvm", :id, "--paravirtprovider", "kvm"]

        # GUI settings (disabled)
        vb.gui = false
      end

      # Provisioning
      worker.vm.provision "shell", inline: <<-SHELL
        echo "Provisioning worker node: #{node_name}"
        echo "IP: #{node_ip}"

        # Set hostname
        hostnamectl set-hostname #{node_name}

        # Add all cluster nodes to /etc/hosts
        cat >> /etc/hosts <<EOF
# Kubernetes cluster nodes
#{nodes.map { |n| "#{n[:ip]} #{n[:name]}" }.join("\n")}
EOF

        # Disable SELinux (required for Kubernetes)
        setenforce 0 || true
        sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

        # Disable swap
        swapoff -a
        sed -i '/ swap / s/^/#/' /etc/fstab

        # Load kernel modules
        modprobe overlay
        modprobe br_netfilter

        # Persist kernel modules
        cat > /etc/modules-load.d/k8s.conf <<EOF
overlay
br_netfilter
EOF

        # Sysctl params for Kubernetes
        cat > /etc/sysctl.d/k8s.conf <<EOF
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF
        sysctl --system

        echo "✓ Worker node #{node_name} pre-provisioned"
      SHELL

      # Run Ansible provisioning on the last worker (when all VMs are up)
      if i == VM_COUNT_WORKERS
        worker.vm.provision "ansible_local" do |ansible|
          ansible.playbook = "/vagrant/ansible/playbooks/site.yml"
          ansible.inventory_path = "/vagrant/ansible/inventory/hosts.ini"
          ansible.limit = "all"
          ansible.verbose = ENV['ANSIBLE_VERBOSITY'] || false
        end
      end
    end
  end

  #############################################################################
  # Post-Configuration
  #############################################################################

  # Generate Ansible inventory
  masters = nodes.select { |n| n[:type] == 'master' }
  workers = nodes.select { |n| n[:type] == 'worker' }
  generate_inventory(masters, workers)

  # Display cluster information
  config.trigger.after :up do |trigger|
    trigger.name = "Display cluster information"
    trigger.ruby do |env, machine|
      puts ""
      puts "╔════════════════════════════════════════════════════════════════╗"
      puts "║              Kubernetes Cluster Information                   ║"
      puts "╚════════════════════════════════════════════════════════════════╝"
      puts ""
      puts "Cluster: #{CLUSTER_NAME}"
      puts "Kubernetes: #{K8S_VERSION}"
      puts ""
      puts "Nodes:"
      nodes.each do |node|
        puts "  • #{node[:name].ljust(15)} #{node[:type].ljust(10)} #{node[:ip]}"
      end
      puts ""
      puts "Next steps:"
      puts "  1. Verify all VMs are running:"
      puts "     $ make status"
      puts ""
      puts "  2. Initialize the Kubernetes cluster:"
      puts "     $ make cluster-init"
      puts ""
      puts "  3. Verify cluster health:"
      puts "     $ make test-cluster"
      puts ""
    end
  end
end
